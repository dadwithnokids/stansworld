<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Stanley's Desk</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Chicago&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --mac-gray: #c0c0c0;
    --mac-dark: #808080;
    --mac-darker: #404040;
    --mac-white: #ffffff;
    --mac-black: #000000;
    --mac-title: #000080;
  }

  /* â”€â”€ ROTATE PROMPT â”€â”€ */
  #rotate-prompt {
    display: none;
    position: fixed; inset: 0;
    background: #000;
    color: #fff;
    font-family: 'Courier New', monospace;
    font-size: 1.1rem;
    text-align: center;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 9999;
    gap: 1.5rem;
  }
  #rotate-prompt .rotate-icon {
    font-size: 3rem;
    animation: rotateAnim 2s ease-in-out infinite;
  }
  @keyframes rotateAnim {
    0%, 100% { transform: rotate(0deg); }
    50% { transform: rotate(90deg); }
  }
  @media (orientation: portrait) and (max-width: 768px) {
    #rotate-prompt { display: flex; }
    body { overflow: hidden; }
  }

  /* â”€â”€ BODY / SCENE â”€â”€ */
  body {
    width: 100vw; height: 100vh;
    overflow: hidden;
    background: #2a1a0a;
    font-family: 'Courier New', monospace;
    cursor: none; /* hide default cursor */
  }

  #scene {
    position: relative;
    width: 100%; height: 100%;
    background: url('Desk_Image.png') center/cover no-repeat;
    background-color: #0d0a08;
  }

  /* Subtle vignette to deepen edges */
  #scene::before {
    content: '';
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse at 50% 45%, transparent 40%, rgba(0,0,0,0.35) 100%);
    pointer-events: none;
  }

  /* â”€â”€ CUSTOM CURSOR (pixelated hand PNG) â”€â”€ */
  #cursor {
    position: fixed;
    width: 36px; height: 36px;
    pointer-events: none;
    z-index: 99999;
    transform: translate(-10px, -4px);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }
  #cursor img {
    width: 100%; height: 100%;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    display: block;
  }
  #cursor.pointing { transform: translate(-10px, -4px) scale(1.1); }
  /* Hide custom cursor on touch devices */
  @media (hover: none), (pointer: coarse) {
    #cursor { display: none !important; }
    body { cursor: auto !important; }
    .hotspot { cursor: pointer !important; }
  }

  /* â”€â”€ HOTSPOTS â”€â”€ */
  .hotspot {
    position: absolute;
    cursor: none;
  }
  .hotspot svg, .hotspot img {
    display: block;
    image-rendering: pixelated;
    max-width: 100%;
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.6));
    transition: filter 0.15s;
    transform-origin: bottom center;
  }
  /* On hover: quick nudge right then settle */
  .hotspot.hovered svg,
  .hotspot.hovered img {
    filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.6)) brightness(1.15);
    animation: hotspot-nudge 0.35s steps(1, end) forwards;
  }
  @keyframes hotspot-nudge {
    0%   { transform: translateX(0px); }
    20%  { transform: translateX(4px); }
    40%  { transform: translateX(6px); }
    60%  { transform: translateX(4px); }
    80%  { transform: translateX(2px); }
    100% { transform: translateX(3px); }
  }

  /* â”€â”€ SPARKLE CANVAS â”€â”€ */
  #sparkle-canvas {
    position: fixed; inset: 0;
    pointer-events: none;
    z-index: 500;  /* below window (1000) and overlay (999) */
  }

  /* â”€â”€ MAC OS CLASSIC MODAL â”€â”€ */
  .mac-window {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    width: min(600px, 90vw);
    max-height: 80vh;
    background: var(--mac-gray);
    border: 2px solid var(--mac-black);
    box-shadow:
      inset 1px 1px 0 var(--mac-white),
      inset -1px -1px 0 var(--mac-dark),
      2px 2px 0 var(--mac-black),
      4px 4px 0 rgba(0,0,0,0.3);
    z-index: 1000;
    font-family: 'Geneva', 'Charcoal', 'Chicago', 'Courier New', monospace;
    font-size: 12px;
    image-rendering: pixelated;
    transform-origin: center center; /* overridden by JS at open time */
  }
  /* Force cursor:none on everything inside the window â€” prevents double cursor */
  .mac-window, .mac-window * {
    cursor: none !important;
  }

  /* Window starts hidden; JS controls visibility during zoom-rect animation */
  .mac-window.active {
    display: block;
  }
  /* .closing is only used briefly while canvas pop plays â€” no CSS anim needed */
  .mac-window.closing { display: none; }

  /* Zoom-rect canvas sits over everything during open animation */
  #zoom-rect-canvas {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 1100;
    image-rendering: pixelated;
  }

  /* Title bar */
  .mac-titlebar {
    background: var(--mac-black);
    color: var(--mac-white);
    display: flex;
    align-items: center;
    padding: 3px 6px;
    gap: 6px;
    user-select: none;
    cursor: move;
  }
  .mac-close-btn {
    width: 12px; height: 12px;
    background: var(--mac-gray);
    border: 1px solid var(--mac-black);
    box-shadow: inset 1px 1px 0 var(--mac-white);
    cursor: pointer;
    flex-shrink: 0;
    display: flex; align-items: center; justify-content: center;
    font-size: 9px; font-weight: bold;
  }
  .mac-close-btn:hover { background: #ff6666; }
  .mac-close-btn::after { content: 'Ã—'; line-height: 1; }

  .mac-title {
    flex: 1;
    text-align: center;
    font-size: 11px;
    font-weight: bold;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  /* Striped title bar lines (Mac OS classic detail) */
  .mac-titlebar-stripes {
    position: absolute;
    top: 0; left: 28px; right: 28px;
    height: 100%;
    background: repeating-linear-gradient(
      90deg,
      transparent 0px,
      transparent 1px,
      var(--mac-dark) 1px,
      var(--mac-dark) 2px
    );
    opacity: 0.3;
    pointer-events: none;
  }

  /* Scrollable content area */
  .mac-content {
    overflow-y: auto;
    max-height: calc(80vh - 80px);
    padding: 12px;
    background: var(--mac-white);
    margin: 4px;
    border: 1px solid var(--mac-dark);
    box-shadow: inset 1px 1px 0 var(--mac-darker);
  }

  .mac-content h2 {
    font-size: 14px;
    font-weight: bold;
    border-bottom: 1px solid var(--mac-dark);
    padding-bottom: 4px;
    margin-bottom: 8px;
  }
  .mac-content p {
    margin-bottom: 8px;
    line-height: 1.5;
  }
  /* Image layout classes */
  .mac-content img {
    display: block;
    margin: 8px 0;
    border: 1px solid var(--mac-dark);
    max-width: 100%;
  }
  /* layout: full (default) */
  .mac-content img.img-full   { width: 100%; }
  /* layout: half */
  .mac-content img.img-half   { width: 50%; }
  /* layout: third */
  .mac-content img.img-third  { width: 33%; }
  /* layout: right â€” floats image to right, text wraps left */
  .mac-content img.img-right  { float: right; width: 45%; margin: 0 0 8px 10px; }
  /* layout: left â€” floats image to left, text wraps right */
  .mac-content img.img-left   { float: left;  width: 45%; margin: 0 10px 8px 0; }
  /* clearfix after floated images */
  .mac-content .img-clear     { clear: both; }
  /* side-by-side row */
  .mac-content .img-row       { display: flex; gap: 6px; margin: 8px 0; }
  .mac-content .img-row img   { flex: 1; width: 0; margin: 0; }
  /* inline link inside description */
  .mac-content a.desc-link {
    color: var(--mac-black);
    text-decoration: underline;
    cursor: pointer;
  }
  .mac-content a.desc-link:hover { background: var(--mac-black); color: var(--mac-white); }

  /* Bottom bar */
  .mac-footer {
    padding: 6px 10px;
    border-top: 1px solid var(--mac-dark);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--mac-gray);
  }
  .mac-link {
    color: var(--mac-black);
    text-decoration: underline;
    cursor: pointer;
    font-size: 11px;
    padding: 2px 6px;
    background: var(--mac-gray);
    border: 1px solid var(--mac-black);
    box-shadow: inset 1px 1px 0 var(--mac-white), 1px 1px 0 var(--mac-darker);
  }
  .mac-link:hover {
    background: var(--mac-black);
    color: var(--mac-white);
  }
  .mac-link:active {
    box-shadow: inset 1px 1px 0 var(--mac-darker);
  }

  /* Scrollbar styling */
  .mac-content::-webkit-scrollbar { width: 14px; }
  .mac-content::-webkit-scrollbar-track {
    background: var(--mac-gray);
    border-left: 1px solid var(--mac-dark);
  }
  .mac-content::-webkit-scrollbar-thumb {
    background: var(--mac-gray);
    border: 1px solid var(--mac-dark);
    box-shadow: inset 1px 1px 0 var(--mac-white);
  }

  /* â”€â”€ OVERLAY â”€â”€ */
  #overlay {
    display: none;
    position: fixed; inset: 0;
    background: rgba(0,0,0,0.4);
    z-index: 999;
  }
  #overlay.active { display: block; }

  /* â”€â”€ DEMO DESK OBJECTS (placeholders) â”€â”€ */
  .demo-label {
    position: absolute;
    color: rgba(255,255,220,0.5);
    font-size: 10px;
    font-family: 'Courier New', monospace;
    pointer-events: none;
    text-align: center;
    transform: translateX(-50%);
  }

  /* â”€â”€ HOVER LABEL â”€â”€ */
  #hover-label {
    position: fixed;
    background: #ffff99;
    border: 1px solid #000;
    padding: 2px 6px;
    font-size: 11px;
    font-family: 'Courier New', monospace;
    pointer-events: none;
    z-index: 9997;
    display: none;
    white-space: nowrap;
  }
</style>
</head>
<body>

<!-- ROTATE PROMPT -->
<div id="rotate-prompt">
  <div class="rotate-icon">ğŸ“±</div>
  <p>Please rotate your device<br>to landscape mode to view this site.</p>
</div>

<!-- CUSTOM CURSOR -->
<div id="cursor"><img src="cursor.png" alt=""></div>

<!-- HOVER TOOLTIP -->
<div id="hover-label"></div>

<!-- SPARKLE CANVAS -->
<canvas id="sparkle-canvas"></canvas>
<canvas id="zoom-rect-canvas"></canvas>

<!-- SCENE -->
<div id="scene">

  <!-- Hotspots added via editor.html / PROJECTS array below -->

</div><!-- /scene -->

<!-- â•â• OVERLAY â•â• -->
<div id="overlay"></div>

<!-- â•â• PROJECT WINDOWS â•â• -->

<!-- Windows are generated dynamically from PROJECTS array below -->

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CURSOR TRACKING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const cursor = document.getElementById('cursor');
document.addEventListener('mousemove', e => {
  cursor.style.left = e.clientX + 'px';
  cursor.style.top = e.clientY + 'px';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPARKLE SYSTEM â€” single burst on hover-enter
// Grows from 1 small diamond â†’ 3-4 pixel diamonds, quick
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('sparkle-canvas');
const ctx = canvas.getContext('2d');
let sparkles = [];

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// Each sparkle: exactly 3 sprite frames â€” small â†’ full â†’ small â†’ gone
class PixelDiamond {
  constructor(x, y, delay) {
    this.x = x;
    this.y = y;
    this.delay = delay;
    this.age = -delay;
    this.duration = 52;          // ~0.87s at 60fps â€” nice and slow
    this.ox = (Math.random() - 0.5) * 18;
    this.oy = (Math.random() - 0.5) * 14;
    this.vy = -0.18 - Math.random() * 0.18; // gentle upward drift
    const colors = ['#ffffff', '#ffe87c', '#ffd700', '#fff0a0', '#c8f0ff', '#ffccff'];
    this.color = colors[Math.floor(Math.random() * colors.length)];
    this.maxSize = Math.floor(Math.random() * 2 + 2); // 2, 3, or 4px
  }

  done() { return this.age > this.duration; }

  draw(ctx) {
    this.age++;
    if (this.age <= 0) return;

    const t = this.age / this.duration;

    // Hard 3-frame stepped size (no smooth tween â€” stays pixel-art)
    let s, alpha;
    if      (t < 0.33) { s = Math.max(1, Math.round(this.maxSize * 0.5)); alpha = 1.0; }  // frame 1: small
    else if (t < 0.66) { s = this.maxSize;                                  alpha = 1.0; }  // frame 2: full
    else if (t < 0.83) { s = Math.max(1, Math.round(this.maxSize * 0.5)); alpha = 0.6; }  // frame 3: small+dim
    else               { return; }                                                            // gone

    this.oy += this.vy;
    const px = Math.round(this.x + this.ox);
    const py = Math.round(this.y + this.oy);

    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;

    ctx.fillRect(px, py, s, s); // center pixel
    for (let i = 1; i <= s + 1; i++) {
      const arm = Math.max(1, s - Math.floor(i * 0.4));
      ctx.fillRect(px + i * s, py, arm, arm);
      ctx.fillRect(px - i * s, py, arm, arm);
      ctx.fillRect(px, py - i * s, arm, arm);
      ctx.fillRect(px, py + i * s, arm, arm);
    }
    ctx.globalAlpha = 1;
  }
}

function spawnBurstAt(el) {
  const rect = el.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top  + rect.height / 3;
  // Exactly 3 sparkles, staggered 10 frames apart (~0.16s each)
  for (let i = 0; i < 3; i++) {
    sparkles.push(new PixelDiamond(cx, cy, i * 10));
  }
}

function animateSparkles() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  sparkles.forEach(s => s.draw(ctx));
  sparkles = sparkles.filter(s => !s.done());
  requestAnimationFrame(animateSparkles);
}
animateSparkles();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HOTSPOT HOVER & CLICK
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const hoverLabel = document.getElementById('hover-label');
let activeHotspot = null;

document.querySelectorAll('.hotspot').forEach(hotspot => {
  hotspot.addEventListener('mouseenter', () => {
    activeHotspot = hotspot;
    cursor.classList.add('pointing');
    hoverLabel.style.display = 'block';
    hoverLabel.textContent = hotspot.dataset.label || '';
    hotspot.classList.add('hovered');
    // Single burst â€” fire once on enter
    spawnBurstAt(hotspot);
  });

  hotspot.addEventListener('mousemove', e => {
    hoverLabel.style.left = (e.clientX + 20) + 'px';
    hoverLabel.style.top = (e.clientY - 10) + 'px';
  });

  hotspot.addEventListener('mouseleave', () => {
    activeHotspot = null;
    cursor.classList.remove('pointing');
    hoverLabel.style.display = 'none';
    hotspot.classList.remove('hovered');
  });

  hotspot.addEventListener('click', () => {
    const projectId = hotspot.dataset.project;
    openWindow(projectId, hotspot);
  });
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// WINDOW MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const overlay = document.getElementById('overlay');

// â”€â”€ ZOOM RECT CANVAS â”€â”€
// Draws the classic Mac-style animated outline rectangle that zooms
// from the hotspot to the window's final position before revealing content.
const zoomCanvas = document.getElementById('zoom-rect-canvas');
const zoomCtx = zoomCanvas.getContext('2d');
function resizeZoomCanvas() {
  zoomCanvas.width  = window.innerWidth;
  zoomCanvas.height = window.innerHeight;
}
resizeZoomCanvas();
window.addEventListener('resize', resizeZoomCanvas);

function animateZoomRect(fromRect, toRect, onDone) {
  // fromRect / toRect: { x, y, w, h } in viewport coords
  const DURATION = 340;  // ms â€” feels like a real old Mac
  const start = performance.now();

  // Dashed line pattern â€” 4px on, 4px off, very pixel-y
  const DASH = [4, 4];
  let dashOffset = 0;

  function frame(now) {
    const elapsed = now - start;
    let t = Math.min(elapsed / DURATION, 1);

    // Ease: fast start, decelerates â€” classic Mac feel
    t = 1 - Math.pow(1 - t, 2.4);

    // Interpolate rect
    const x = fromRect.x + (toRect.x - fromRect.x) * t;
    const y = fromRect.y + (toRect.y - fromRect.y) * t;
    const w = fromRect.w + (toRect.w - fromRect.w) * t;
    const h = fromRect.h + (toRect.h - fromRect.h) * t;

    zoomCtx.clearRect(0, 0, zoomCanvas.width, zoomCanvas.height);

    const rx = Math.round(x), ry = Math.round(y);
    const rw = Math.round(w), rh = Math.round(h);

    // Soft fill â€” Mac gray tint that fades in as the rect grows.
    // fillAlpha goes 0 â†’ 0.18 over the animation so it feels like
    // the window body is materialising behind the outline.
    const fillAlpha = t * 0.18;
    zoomCtx.globalAlpha = fillAlpha;
    zoomCtx.fillStyle = '#c8c8c8';
    zoomCtx.fillRect(rx, ry, rw, rh);
    zoomCtx.globalAlpha = 1;

    // Marching-ants outline â€” outer black
    zoomCtx.strokeStyle = '#000000';
    zoomCtx.lineWidth = 2;
    zoomCtx.setLineDash(DASH);
    zoomCtx.lineDashOffset = -dashOffset;
    zoomCtx.strokeRect(rx, ry, rw, rh);

    // Inner white offset â€” double-outline pixel look
    zoomCtx.strokeStyle = '#ffffff';
    zoomCtx.lineWidth = 1;
    zoomCtx.lineDashOffset = -dashOffset - 4;
    zoomCtx.strokeRect(rx + 1, ry + 1, rw - 2, rh - 2);

    zoomCtx.setLineDash([]); // reset

    dashOffset = (dashOffset + 1.5) % 8; // march the ants

    if (t < 1) {
      requestAnimationFrame(frame);
    } else {
      zoomCtx.clearRect(0, 0, zoomCanvas.width, zoomCanvas.height);
      onDone();
    }
  }

  requestAnimationFrame(frame);
}

// â”€â”€ Z-INDEX MANAGER â”€â”€
// Each time a window is clicked or opened it gets the highest z-index
// so it floats above all others. Base is 1000, increments up.
let topZ = 1000;
function bringToFront(win) {
  topZ++;
  win.style.zIndex = topZ;
}

// Stagger offset so multiple windows don't open perfectly stacked
let openCount = 0;

function openWindow(id, originEl) {
  const win = document.getElementById('window-' + id);
  if (!win) return;

  // If already open, just bring to front â€” don't re-animate
  if (win.classList.contains('active')) {
    bringToFront(win);
    return;
  }

  // Measure window height off-screen
  win.style.visibility = 'hidden';
  win.style.display = 'block';
  const winW = Math.min(600, window.innerWidth * 0.9);
  const winH = Math.min(win.offsetHeight, window.innerHeight * 0.8);
  win.style.display = 'none';
  win.style.visibility = '';

  // Cascade offset â€” each new window opens slightly offset from center
  // so stacked windows are visibly separate
  const cascade = (openCount % 5) * 22; // 0, 22, 44, 66, 88 px
  openCount++;

  const toRect = {
    x: (window.innerWidth  - winW) / 2 + cascade,
    y: (window.innerHeight - winH) / 2 + cascade,
    w: winW,
    h: winH,
  };

  let fromRect;
  if (originEl) {
    const r = originEl.getBoundingClientRect();
    fromRect = { x: r.left, y: r.top, w: r.width, h: r.height };
  } else {
    fromRect = {
      x: window.innerWidth  / 2 - 4,
      y: window.innerHeight / 2 - 4,
      w: 8, h: 8
    };
  }

  animateZoomRect(fromRect, toRect, () => {
    // Position at the cascaded location using absolute px (not % + transform)
    // so drag works cleanly from the start without any coordinate system switch
    win.style.transform  = 'none';
    win.style.left       = toRect.x + 'px';
    win.style.top        = toRect.y + 'px';
    win.style.opacity    = '0';
    win.style.transition = '';
    win.classList.remove('closing');
    win.style.display    = 'block';
    bringToFront(win);
    void win.offsetWidth;
    win.style.transition = 'opacity 0.18s ease-out';
    win.style.opacity    = '1';

    setTimeout(() => {
      win.style.transition = '';
      win.classList.add('active');
    }, 200);
  });
}

function closeWindow(id) {
  const win = document.getElementById('window-' + id);
  if (!win) return;

  const TILE     = 4;
  const DURATION = 1100; // faster
  const w = win.offsetWidth;
  const h = win.offsetHeight;

  // Build tile death times up front
  const cols  = Math.ceil(w / TILE);
  const rows  = Math.ceil(h / TILE);
  const tiles = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      tiles.push({ x: c * TILE, y: r * TILE, deathT: Math.random() });
    }
  }

  // Overlay canvas â€” drawn OVER the window using normal compositing.
  // Instead of destination-out (which needs transparency), we draw
  // BACKGROUND-COLORED tiles over the window to "erase" regions â€”
  // but we don't know the bg color. So instead: we reduce the window's
  // opacity globally while using clip regions to keep the surviving
  // tiles looking full-opacity.
  //
  // Simplest approach that actually works:
  // Keep window visible. Each frame, build a clip path from all the
  // tiles that are still alive â€” window is only visible through those tiles.

  win.style.isolation = 'isolate';

  // Create a canvas that sits on top of the window, same size,
  // draws a solid mask. We use it to rebuild the clip region each frame.
  // Actually: use SVG clipPath on the window itself.
  // Generate a <clipPath> with rects for surviving tiles, update each frame.

  // Create SVG clip path element
  const svgNS  = 'http://www.w3.org/2000/svg';
  const svg    = document.createElementNS(svgNS, 'svg');
  svg.style.cssText = 'position:absolute;width:0;height:0;overflow:hidden;';
  const defs   = document.createElementNS(svgNS, 'defs');
  const clipEl = document.createElementNS(svgNS, 'clipPath');
  const clipId = 'dissolve-clip-' + id;
  clipEl.setAttribute('id', clipId);
  defs.appendChild(clipEl);
  svg.appendChild(defs);
  document.body.appendChild(svg);

  win.style.clipPath = `url(#${clipId})`;

  const start = performance.now();

  function drawFrame(now) {
    const elapsed  = now - start;
    const progress = Math.min(elapsed / DURATION, 1);
    // Ease: slow start then accelerate â€” pixels trickle then rush
    const ease = Math.pow(progress, 0.8);

    // Rebuild clip path from surviving tiles
    // Batch into one big path string for performance
    let pathStr = '';
    let allDead = true;

    tiles.forEach(tile => {
      if (ease < tile.deathT) {
        // Still alive â€” include in clip
        pathStr += `M${tile.x},${tile.y}h${TILE}v${TILE}h-${TILE}Z `;
        allDead = false;
      }
      // else: dead â€” not in clip, so window is invisible there
    });

    if (allDead || progress >= 1) {
      // Done â€” clean up
      win.style.clipPath  = '';
      win.style.isolation = '';
      win.classList.remove('active', 'closing');
      win.style.display   = 'none';
      win.style.left = win.style.top = win.style.transform = win.style.zIndex = '';
      svg.remove();
      return;
    }

    // Apply the clip path as a single SVG path element
    clipEl.innerHTML = `<path d="${pathStr}"/>`;
    requestAnimationFrame(drawFrame);
  }

  requestAnimationFrame(drawFrame);

  const anyOpen = document.querySelectorAll('.mac-window.active').length > 0;
  if (!anyOpen) overlay.classList.remove('active');
}

// Close buttons
document.querySelectorAll('.mac-close-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    closeWindow(btn.dataset.close);
  });
});

// No overlay click-to-close â€” windows stay open until X is clicked.
// Overlay is now just a subtle dim behind the topmost window.

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DRAGGABLE WINDOWS + BRING TO FRONT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Single shared drag state â€” only one window drags at a time
let dragState = null;

// Attach drag to a window element (called for both static + dynamic windows)
function makeDraggable(win) {
  const titlebar = win.querySelector('.mac-titlebar');
  if (!titlebar) return;

  // Clicking anywhere on the window brings it to front
  win.addEventListener('mousedown', () => bringToFront(win));

  titlebar.addEventListener('mousedown', e => {
    if (e.target.classList.contains('mac-close-btn')) return;
    e.preventDefault();
    bringToFront(win);

    const rect = win.getBoundingClientRect();
    // Windows are positioned with absolute left/top px â€” read directly
    dragState = {
      win,
      startX: e.clientX - rect.left,
      startY: e.clientY - rect.top,
    };
  });
}

document.addEventListener('mousemove', e => {
  if (!dragState) return;
  dragState.win.style.left = (e.clientX - dragState.startX) + 'px';
  dragState.win.style.top  = (e.clientY - dragState.startY) + 'px';
});

document.addEventListener('mouseup', () => { dragState = null; });

// Attach to all static windows on load
document.querySelectorAll('.mac-window').forEach(makeDraggable);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADDING NEW HOTSPOTS via JSON config
// (Paste your JSON in the array below to add projects without coding)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
  HOW TO ADD A NEW PROJECT:
  Add an object to the PROJECTS array below:

  {
    id: "my-new-project",
    label: "My New Project",         // hover tooltip
    left: "60%",                     // horizontal position on desk
    top: "55%",                      // vertical position on desk  
    width: "10%",                    // size
    imageSrc: "path/to/image.png",   // your desk object image
    title: "My New Project",
    description: "Describe it here...",
    images: ["img1.jpg", "img2.jpg"],
    link: "https://myproject.com",
    linkText: "View Project"
  }
*/
const PROJECTS = [
  {
    "id": "airchrysalis",
    "label": "Air Chrysalis",
    "left": "20.6%",
    "top": "49.2%",
    "width": "8.6%",
    "imageSrc": "minidisc-player.png",
    "title": "Air Chrysalis",
    "description": "With a strong sense of aesthetics and DIY hacking bravado, Air Chrysalis is both a dream pop duo and culture-jamming visual art project equally imprinted by analog and digital. Sharing an appreciation for retrofuturism and hauntology, as the reference to the mysterious sarcophagus in Haruki Murakamiâ€™s 1Q84 suggests, Stanley Chase III (vocals, keys) and Michael Powell (guitar, synth) began channeling their unified vision into a pastiche of misremembered nocturnal pop in the summer of 2019.\n\nDefining their sound through driving, gritty, enveloping low-end synth lines and aerodynamic, hypnogogic guitar buoyed over parallax vocals, Air Chrysalis occupies a stylized space between new wave, shoegaze, trip hop, and incandescent, adventurous, experimental pop music. The duo debuted in April 2020 with the neon-noir cinematic single â€œBeyond My God.â€ The song saw success on non-commercial radio, coupled with a video that stitched together vintage CRT monitor visuals and advanced projection mapping. Air Chrysalis released their seven-song eponymous EP in September, recorded and mixed by Anne Gauthier (My Morning Jacket, Dean & Britta), with a trippy rotoscopic animated video for the luminous opener â€œHelical Scanâ€ following at the end of the year.\n\nAir Chrysalis will release their debut full-length in summer 2021, featuring contributions from White Reaperâ€˜s Nick Wilkerson, SEE TAI, and others. An elaborate live show is ready to deploy once, you know, concerts are a thing again.\n\nFor publicity purposes, letâ€™s say RIYL Black Moth Super Rainbow, Beach House, M83, Oneohtrix Point Never \n\nâ€œAir Chrysalis has crafted a synth-heavy masterpiece this year, recalling Slowdive or Mogwai, as filtered through a pop-friendly sieve of vaporwave and Kraftwerk.â€ â€“ [LEO Weekly, Best Locals Songs of 2020](https://www.leoweekly.com/2021/01/2020-leo-playlist-15-favorite-local-songs-past-year/)\n\nâ€œThese dudes are penetrating my molecular structureâ€ â€“ Clay Lapari, Exxpired Music and respected LA insider (!)\n\n â€œIs this band the new Joy Division? Was parked and couldnâ€™t leave the car til it finished.â€ â€“ Some commenters on YouTube\n\nAs heard in regular rotation on WFPK 91.9 and WXOX 97.1! Cool!",
    "images": [
      "acpic.jpg|right",
      "acpic2.jpg|left"
    ],
    "link": "https://airchrysalissound.com/",
    "linkText": "View Project"
  }
];

function buildProjectFromConfig(project) {
  // Create hotspot
  const hotspot = document.createElement('div');
  hotspot.className = 'hotspot';
  hotspot.dataset.project = project.id;
  hotspot.dataset.label = project.label;
  hotspot.style.left = project.left;
  hotspot.style.top = project.top;
  hotspot.style.width = project.width || '10%';

  if (project.imageSrc) {
    const img = document.createElement('img');
    img.src = project.imageSrc;
    img.alt = project.label;
    hotspot.appendChild(img);
  }

  document.getElementById('scene').appendChild(hotspot);

  // Create window
  const win = document.createElement('div');
  win.className = 'mac-window';
  win.id = 'window-' + project.id;

  // Build image HTML â€” each image can have a layout suffix:
  // "photo.jpg"              â†’ full width (default)
  // "photo.jpg|half"         â†’ 50% width
  // "photo.jpg|third"        â†’ 33% width
  // "photo.jpg|right"        â†’ float right, text wraps
  // "photo.jpg|left"         â†’ float left, text wraps
  // "photo.jpg|row:photo2.jpg|row:photo3.jpg" â†’ side-by-side row

  const images = project.images || [];
  let imgHTML = '';
  let i = 0;
  while (i < images.length) {
    const raw = images[i];
    const [src, layout = 'full'] = raw.split('|');

    if (layout.startsWith('row')) {
      // Collect all consecutive row items
      const rowImgs = [src];
      while (i + 1 < images.length && images[i+1].split('|')[1] === 'row') {
        i++;
        rowImgs.push(images[i].split('|')[0]);
      }
      imgHTML += `<div class="img-row">${rowImgs.map(s =>
        `<img src="${s}" alt="${project.title}">`).join('')}</div>`;
    } else if (layout === 'right' || layout === 'left') {
      imgHTML += `<img src="${src}" alt="${project.title}" class="img-${layout}">`;
    } else if (layout === 'half' || layout === 'third') {
      imgHTML += `<img src="${src}" alt="${project.title}" class="img-${layout}">`;
    } else {
      imgHTML += `<img src="${src}" alt="${project.title}" class="img-full">`;
    }
    i++;
  }
  // Clear floats after images
  if (imgHTML) imgHTML += '<div class="img-clear"></div>';

  // Parse description â€” supports:
  //   [link text](url)   â†’ hyperlink
  //   **bold**           â†’ bold
  //   *italic*           â†’ italic
  //   blank line         â†’ new paragraph
  function parseDesc(raw) {
    return (raw || '')
      .split(/\n\s*\n/)               // split on blank lines â†’ paragraphs
      .map(para => para
        .replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g,
          '<a class="desc-link" href="$2" target="_blank" rel="noopener">$1</a>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*([^*]+?)\*/g,    '<em>$1</em>')
        .replace(/\n/g, '<br>')
      )
      .map(para => `<p>${para}</p>`)
      .join('');
  }

  const descHTML = parseDesc(project.description);

  win.innerHTML = `
    <div class="mac-titlebar" data-window="${project.id}">
      <div class="mac-close-btn" data-close="${project.id}"></div>
      <div style="position:relative;flex:1;text-align:center;">
        <div class="mac-titlebar-stripes"></div>
        <span class="mac-title">${project.title}</span>
      </div>
      <div style="width:12px;"></div>
    </div>
    <div class="mac-content">
      <h2>${project.title}</h2>
      ${imgHTML}
      ${descHTML}
    </div>
    <div class="mac-footer">
      <span style="font-size:10px;color:#666;">Stanley's Desk Â© 2024</span>
      ${project.link ? `<a class="mac-link" href="${project.link}" target="_blank" rel="noopener">â†— ${project.linkText || 'View Project'}</a>` : ''}
    </div>
  `;
  document.body.appendChild(win);

  // Attach events
  hotspot.addEventListener('mouseenter', () => {
    activeHotspot = hotspot;
    cursor.classList.add('pointing');
    hoverLabel.style.display = 'block';
    hoverLabel.textContent = hotspot.dataset.label;
    hotspot.classList.add('hovered');
    spawnBurstAt(hotspot);
  });
  hotspot.addEventListener('mousemove', e => {
    hoverLabel.style.left = (e.clientX + 20) + 'px';
    hoverLabel.style.top = (e.clientY - 10) + 'px';
  });
  hotspot.addEventListener('mouseleave', () => {
    activeHotspot = null;
    cursor.classList.remove('pointing');
    hoverLabel.style.display = 'none';
    hotspot.classList.remove('hovered');
  });
  hotspot.addEventListener('click', () => openWindow(project.id, hotspot));

  win.querySelector('.mac-close-btn').addEventListener('click', () => closeWindow(project.id));

  // Make draggable + bring-to-front using the shared drag system
  makeDraggable(win);
}

PROJECTS.forEach(buildProjectFromConfig);
</script>
</body>
</html>
